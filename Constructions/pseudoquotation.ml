(*Todo: Implement "raw quotation" - directly convert HOL's data structure to a type of Epsilon using OCaml's faculties*)

(*Simple conversion functions to take HOL types and convert them to the type of type*)

(*This type is used to encode functions for use by makeFunction
Singleton - a single type that will be chained to the front of the function like normal 
Function - Represents a list of singletons - will be used when there is a need to take functions as arguments such as a function of type num -> (num->bool) ->bool
*)
type func =
	| Singleton of string
	| Function of (func)list;;

(*Translates HOL's types into the type names of epsilon*)
let translateType tyStr = match tyStr with
	| "num" -> "NaturalInd"
	| "real" -> "RealInd"
	| "int" -> "IntegerInd"
	| "bool" -> "Bool" 
	| _ -> tyStr;;

(*Converts functions by taking an exploded strings, think about returning these in a linked list for easier conversion to an HOL function?*)
let rec breakFunction parans depth before remaining = 

	let rec skipParans text depth count= 
	match text with
	| "(" :: rest -> skipParans rest depth (count+1)
	| ")" :: rest when count > 0 -> skipParans rest depth (count-1)
	| ")" :: rest -> if depth = 1 then breakFunction false 0 "" rest else breakFunction true (depth-1) "" rest
	| a :: rest -> skipParans rest depth count
	| [] -> failwith "No closing parantheses" in

	match remaining with
	| "-" :: ">" :: rest -> if not (before = "") then (Singleton before) :: (breakFunction parans depth "" rest) else (breakFunction parans depth "" rest)
	| [] -> if not (before = "") then [(Singleton before)] else []
	| "(" :: rest -> (Function (breakFunction true (depth+1) "" rest)) :: (skipParans rest (depth+1) 0)
	| ")" :: rest -> if parans then if not (before = "") then [(Singleton before)] else [] else failwith "Mismatched parantheses"
	| a :: rest -> breakFunction parans depth (before ^ a) rest;;



(*Takes a list generated by breakFunction and returns it as a type of Fun*)
let rec makeFun split = 
	(*Converts the function datatype's arguments*)
	let rec convertFuncArg item = match item with
	| Singleton a -> mk_const((translateType a),[])
	| Function a -> makeFun a in


	match split with
	| [a;b] -> mk_comb(mk_comb(mk_const(("Fun"),[]),(convertFuncArg a)),(convertFuncArg b))
	| a :: rest -> mk_comb(mk_comb(mk_const(("Fun"),[]),(convertFuncArg a)),(makeFun rest))
	| _ -> failwith "List must contain at least two elements to be able to create a function type out of it";;

(*This function handles more advanced types such as Tyvars and functions*)
let makeTypeWithArgs tyStr = match tyStr with
	| "T" :: "y" :: "v" :: "a" :: "r" :: " " :: rest -> mk_comb(mk_const("Tyvar",[]),mk_var((implode rest),mk_type("list",[`:char`])))
	| _ -> if (breakFunction false 0 "" tyStr) = [(Singleton (implode tyStr))] then failwith "This is not a valid type name" else makeFun(breakFunction false 0 "" tyStr);;

(*Takes a string and converts it into it's HOL equivelant*)
let makeType tyStr = match tyStr with
	| "NaturalInd" | "RealInd" | "IntegerInd" | "Ind" | "Bool" -> mk_const(tyStr,[])
	| _ -> makeTypeWithArgs (explode tyStr);;

(*Function to actually handle conversion*)
let rec quoteRecursion term = match term with
	| Var (vName, vType) -> mk_comb(mk_comb(mk_const("QuoVar",[]),mk_string(vName)),(makeType (translateType (string_of_type vType))))
	| Const (cName, cType) -> mk_comb(mk_comb(mk_const("QuoConst",[]),mk_string(cName)),(makeType (translateType (string_of_type cType))))
	| Comb(E1,E2) -> mk_comb(mk_comb(mk_const("App",[]),(quoteRecursion E1)), (quoteRecursion E2))
	| Abs(E1, E2) -> mk_comb(mk_comb(mk_const("Abs",[]),(quoteRecursion E1)), (quoteRecursion E2));;

(*Function to take an expression, and convert it into a type of epsilon wrapped inside of a Quote*)
let quote exp = mk_comb(mk_const("Quote",[]),(quoteRecursion exp));;